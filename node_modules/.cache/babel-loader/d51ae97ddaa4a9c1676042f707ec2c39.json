{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"D:/projects/laptop-design-master/my-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.segmentBounce = exports.calcClosestPtOnSegment = exports.parsePaths = exports.drawPolygonMaskPath = exports.drawPolygonMask = void 0;\n\nvar ColorUtils_1 = require(\"../../Utils/ColorUtils\");\n\nvar Vector_1 = require(\"../../Core/Utils/Vector\");\n\nvar NumberUtils_1 = require(\"../../Utils/NumberUtils\");\n\nfunction drawPolygonMask(context, rawData, stroke) {\n  var color = (0, ColorUtils_1.colorToRgb)(stroke.color);\n\n  if (!color) {\n    return;\n  }\n\n  context.beginPath();\n  context.moveTo(rawData[0].x, rawData[0].y);\n\n  var _iterator = _createForOfIteratorHelper(rawData),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      context.lineTo(item.x, item.y);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  context.closePath();\n  context.strokeStyle = (0, ColorUtils_1.getStyleFromRgb)(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\n\nexports.drawPolygonMask = drawPolygonMask;\n\nfunction drawPolygonMaskPath(context, path, stroke, position) {\n  context.translate(position.x, position.y);\n  var color = (0, ColorUtils_1.colorToRgb)(stroke.color);\n\n  if (!color) {\n    return;\n  }\n\n  context.strokeStyle = (0, ColorUtils_1.getStyleFromRgb)(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n}\n\nexports.drawPolygonMaskPath = drawPolygonMaskPath;\n\nfunction parsePaths(paths, scale, offset) {\n  var _a;\n\n  var res = [];\n\n  var _iterator2 = _createForOfIteratorHelper(paths),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var path = _step2.value;\n      var segments = path.element.pathSegList,\n          len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0,\n          p = {\n        x: 0,\n        y: 0\n      };\n\n      for (var i = 0; i < len; i++) {\n        var segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n        var svgPathSeg = window.SVGPathSeg;\n\n        switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n          case svgPathSeg.PATHSEG_MOVETO_ABS:\n          case svgPathSeg.PATHSEG_LINETO_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n          case svgPathSeg.PATHSEG_ARC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n            {\n              var absSeg = segment;\n              p.x = absSeg.x;\n              p.y = absSeg.y;\n              break;\n            }\n\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n            p.x = segment.x;\n            break;\n\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n            p.y = segment.y;\n            break;\n\n          case svgPathSeg.PATHSEG_LINETO_REL:\n          case svgPathSeg.PATHSEG_MOVETO_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n          case svgPathSeg.PATHSEG_ARC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n            {\n              var relSeg = segment;\n              p.x += relSeg.x;\n              p.y += relSeg.y;\n              break;\n            }\n\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n            p.x += segment.x;\n            break;\n\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n            p.y += segment.y;\n            break;\n\n          case svgPathSeg.PATHSEG_UNKNOWN:\n          case svgPathSeg.PATHSEG_CLOSEPATH:\n            continue;\n        }\n\n        res.push({\n          x: p.x * scale + offset.x,\n          y: p.y * scale + offset.y\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return res;\n}\n\nexports.parsePaths = parsePaths;\n\nfunction calcClosestPtOnSegment(s1, s2, pos) {\n  var _ref = (0, NumberUtils_1.getDistances)(pos, s1),\n      dx = _ref.dx,\n      dy = _ref.dy,\n      _ref2 = (0, NumberUtils_1.getDistances)(s2, s1),\n      dxx = _ref2.dx,\n      dyy = _ref2.dy,\n      t = (dx * dxx + dy * dyy) / (Math.pow(dxx, 2) + Math.pow(dyy, 2)),\n      res = {\n    x: s1.x + dxx * t,\n    y: s1.x + dyy * t,\n    isOnSegment: t >= 0 && t <= 1\n  };\n\n  if (t < 0) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > 1) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n\n  return res;\n}\n\nexports.calcClosestPtOnSegment = calcClosestPtOnSegment;\n\nfunction segmentBounce(start, stop, velocity) {\n  var _ref3 = (0, NumberUtils_1.getDistances)(start, stop),\n      dx = _ref3.dx,\n      dy = _ref3.dy,\n      wallAngle = Math.atan2(dy, dx),\n      wallNormal = Vector_1.Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)),\n      d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}\n\nexports.segmentBounce = segmentBounce;","map":{"version":3,"sources":["D:/projects/laptop-design-master/my-app/node_modules/tsparticles/cjs/Plugins/PolygonMask/Utils.js"],"names":["Object","defineProperty","exports","value","segmentBounce","calcClosestPtOnSegment","parsePaths","drawPolygonMaskPath","drawPolygonMask","ColorUtils_1","require","Vector_1","NumberUtils_1","context","rawData","stroke","color","colorToRgb","beginPath","moveTo","x","y","item","lineTo","closePath","strokeStyle","getStyleFromRgb","lineWidth","width","path","position","translate","opacity","paths","scale","offset","_a","res","segments","element","pathSegList","len","numberOfItems","p","i","segment","getItem","svgPathSeg","window","SVGPathSeg","pathSegType","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","absSeg","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","relSeg","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","push","s1","s2","pos","getDistances","dx","dy","dxx","dyy","t","isOnSegment","start","stop","velocity","wallAngle","Math","atan2","wallNormal","Vector","create","sin","cos","d","multTo","subFrom"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.segmentBounce = exports.calcClosestPtOnSegment = exports.parsePaths = exports.drawPolygonMaskPath = exports.drawPolygonMask = void 0;\nconst ColorUtils_1 = require(\"../../Utils/ColorUtils\");\nconst Vector_1 = require(\"../../Core/Utils/Vector\");\nconst NumberUtils_1 = require(\"../../Utils/NumberUtils\");\nfunction drawPolygonMask(context, rawData, stroke) {\n    const color = (0, ColorUtils_1.colorToRgb)(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.beginPath();\n    context.moveTo(rawData[0].x, rawData[0].y);\n    for (const item of rawData) {\n        context.lineTo(item.x, item.y);\n    }\n    context.closePath();\n    context.strokeStyle = (0, ColorUtils_1.getStyleFromRgb)(color);\n    context.lineWidth = stroke.width;\n    context.stroke();\n}\nexports.drawPolygonMask = drawPolygonMask;\nfunction drawPolygonMaskPath(context, path, stroke, position) {\n    context.translate(position.x, position.y);\n    const color = (0, ColorUtils_1.colorToRgb)(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.strokeStyle = (0, ColorUtils_1.getStyleFromRgb)(color, stroke.opacity);\n    context.lineWidth = stroke.width;\n    context.stroke(path);\n}\nexports.drawPolygonMaskPath = drawPolygonMaskPath;\nfunction parsePaths(paths, scale, offset) {\n    var _a;\n    const res = [];\n    for (const path of paths) {\n        const segments = path.element.pathSegList, len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0, p = {\n            x: 0,\n            y: 0,\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n            const svgPathSeg = window.SVGPathSeg;\n            switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n                case svgPathSeg.PATHSEG_MOVETO_ABS:\n                case svgPathSeg.PATHSEG_LINETO_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                case svgPathSeg.PATHSEG_ARC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {\n                    const absSeg = segment;\n                    p.x = absSeg.x;\n                    p.y = absSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                    p.x = segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                    p.y = segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_REL:\n                case svgPathSeg.PATHSEG_MOVETO_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                case svgPathSeg.PATHSEG_ARC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {\n                    const relSeg = segment;\n                    p.x += relSeg.x;\n                    p.y += relSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                    p.x += segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                    p.y += segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_UNKNOWN:\n                case svgPathSeg.PATHSEG_CLOSEPATH:\n                    continue;\n            }\n            res.push({\n                x: p.x * scale + offset.x,\n                y: p.y * scale + offset.y,\n            });\n        }\n    }\n    return res;\n}\nexports.parsePaths = parsePaths;\nfunction calcClosestPtOnSegment(s1, s2, pos) {\n    const { dx, dy } = (0, NumberUtils_1.getDistances)(pos, s1), { dx: dxx, dy: dyy } = (0, NumberUtils_1.getDistances)(s2, s1), t = (dx * dxx + dy * dyy) / (dxx ** 2 + dyy ** 2), res = {\n        x: s1.x + dxx * t,\n        y: s1.x + dyy * t,\n        isOnSegment: t >= 0 && t <= 1,\n    };\n    if (t < 0) {\n        res.x = s1.x;\n        res.y = s1.y;\n    }\n    else if (t > 1) {\n        res.x = s2.x;\n        res.y = s2.y;\n    }\n    return res;\n}\nexports.calcClosestPtOnSegment = calcClosestPtOnSegment;\nfunction segmentBounce(start, stop, velocity) {\n    const { dx, dy } = (0, NumberUtils_1.getDistances)(start, stop), wallAngle = Math.atan2(dy, dx), wallNormal = Vector_1.Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)), d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n    wallNormal.multTo(d);\n    velocity.subFrom(wallNormal);\n}\nexports.segmentBounce = segmentBounce;\n"]},"metadata":{},"sourceType":"script"}